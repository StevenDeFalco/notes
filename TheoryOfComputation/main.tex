% A note-taking template by Steven DeFalco
% github.com/StevenDeFalco/notes

\documentclass{article}

% import note styles
\usepackage{../styles}

% Heading information
\title{CS334: Theory of Computation Notes}
\author{Steven DeFalco}
\date{Fall 2023}


\begin{document}


\maketitle
\tableofcontents
\newpage


% Notes start here

\section{Introduction}

\subsection{Automata, Computability, and Complexity}

The central question of \define{complexity theory} is \emph{what makes some problems computationally hard and others easy?}; the answer is unknown. Cryptography is unique in that is specifically requires computational problems that are hard, rather than easy. 
In \define{complexity theory}, the objective is to classify problems as easy ones and hard ones; whereas in \define{computability} theory, the classification of probelms is by those that are solvable and those that are not. 

\define{Automata theory} deals with the definitions and properties of mathematical models of computations. 

\subsection{Mathematical Notions and Terminology}

\subsubsection{Sets} 

A \define{set} is a group of objects represented as a unit. Sets may contain any type of object, including numbers, symbols, and even othber sets. The objects in a set are called its \emph{elements} or \emph{members}. One way to describe a set is to list the set's elements inside braces. Thus the set  $$S = \{7,21,57\}$$ contains the elements 7, 21, and 59. The symbols $\in$ and $\notin$ denote set membership and nonmembership. We say that $A$ is a \define{subset} of $B$, written $A \subseteq B$, if every member of $A$ is also a member of $B$. We say that $A$ is a \define{proper subset} of $B$, written $A \subset B$, if $A$ is a subset of $B$ and not equal to $B$. \\ 

The order of describing a set doesn't matter, nor does repetition of its members. If we do want to take the number of occurrences of members into account, we call the group a \define{multiset} instead of a set. An \define{infinite set} contains infinitely many elements. \\ 

We write the set of \define{natural numbers} $N$ as $$\{1,2,3,\dots\}$$. The set of \define{integers} $Z$ is written as $$\{\dots,-2,-1,0,1,2,\dots\}$$ The set with zero members is called the \define{empty set} and is written $\emptyset$. A set with one member is sometimes called a \define{singleton set} and a set with two members is called an \define{unordered pair}. \\ 

When we want to describe a set containing elements according to some rule, we write $\{n \vert \textrm{rule about} n\}$. \\ 

If we have two sets $A$ and $B$, the \define{union} of $A$ and $B$, written $A \cup B$, is the set we get by combining all the leements in $A$ and $B$ into a single set. The \define{intersection} of $A$ and $B$, written $A \cap B$, is the set of elements that are both $A$ and $B$. The \define{complement} of $A$, written $\overline{A}$, is the set of elelements under consideration that are $not$ in $A$. \\ 

\subsubsection{Sequences and Tuples}

A \define{sequence} of objects is a list of these objects in some order. We usually designate a sequence by writing the list within parentheses. For example, the sequence 7,21,57 would be written $$(7,21,57)$$. The order does matter in a set. \\ 

Finite sequences often are called \define{tuples}. A sequence with $k$ elements is a \define{k-tuple}. A 2-tuple is also called an \define{ordered pair}. \\ 

Sets and sequences may appear as elements of other sets and sequences. For example, the \define{power set} of $A$ is the set of all subsets of $A$. If $A$ is the set {0,1}, the power set of $A$ is the set $\{\emptyset, \{0\}, \{1\}, \{0,1\}\}$. \\ 

If $A$ and $B$ are two sets, the \define{Cartesian product} or def{cross product} of $A$ and $B$, written $A \times B$, is the set of all ordered pairs wherein the first element is a member of $A$ and the second elemetn is a member of $B$. 

\subsubsection{Functions and Relations} 

A \define{function} is an object that sets up an input-output relationship. A function takes an input and produces and output. In every function, the same input always produces the same output. \\ 

A function is also called a \define{mapping}, and, if $f(a) = b$, we say that $f$ maps $a$ to $b$. \\ 

The set of possible inputs to the function is called its \define{domain}. The outputs of a function come from a set called the \define{range}. The notation for saying that $f$ is a function with domain $D$ and range $R$ is $$f: D \rightarrow R$$ \\ 

When the domain of a function $f$ is $A_{1} \times \cdots \times A_{k}$ for some sets $A_{1}, \dots, A_{k}$, the input to $f$ is a k-tuple and we call the $a_i$ the \define{arguments} to $f$. A function with $k$ arguments is called a \define{k-ary function}, and $k$ is called the \define{arity} of the function. If $k$ is 1, $f$ has a single argument and $f$ called a \define{unary function}. If $k$ is 2, $f$ is a \define{binaryh function}. Certain familiar binary functions are written in a special \define{infix notation}, with the symbol for the function placed between its two arguments, rather than in \define{prefix notation}, with the symbol preceding. \\ 

A \define{predicate} or \define{property} is a function whose range is $\{\textrm{TRUE}, \textrm{FALSE}\}$. For example, let $even$ be a property that is TRUE if its input is an even number and FALSE if its input is an odd number. \\ 

A property whose domain is a set of k-tuples $A \times \cdots \times A$ is called a \define{relation}, a \define{k-ary relation}, or a \define{k-ary relation on A}. \\

A special type of binaryh relation, called an \define{equivalence relation}, captures the notion of two objects being equal in some feature. A binary relation $R$ is an equivalence relation if $R$ satisfies three conditions:

\begin{enumerate}
  \item $R$ is \define{reflexive} if for every $x$, $xRx$;
  \item $R$ is \define{symmetric} if for every $x$ and $y$, $xRy$ implies $yRx$; and 
  \item $R$ is \define{transitive} if for every $x$,$y$, and $z$, $xRy$ and $yRz$ implies $xRz$. 
\end{enumerate}

\subsubsection{Graphs}

An \define{undirected graph}, or simply a \define{graph}, is a set of points with lines connecting some of the points. The points are called \define{nodes} or \define{vertices}, and the lines are called \define{edges}. \\ 

The number of edges at a particular node is the \define{degree} of that node. No more thatn one edge is allowed between any two nodes. We may allow an edge from a node to itself, called a \define{self-loop}. \\ 

We say that graph $G$ is a \define{subgraph} of graph $H$ is the nodes of $G$ are a subset of the nodes of $H$, and the edges of $G$ are the edges of $H$ on the corresponding nodes. \\ 

A \define{path} in a graph is a seqeunce of nodes connected by edges. A \define{simple path} is a path that doesn't repeat any nodes. A graph is \define{connected} if every two nodes have a path between them. A path is a \define{cycle} if it starts and ends in the same node. A \define{simple cycle} is one that contains at least three nodes and repeates only the first and last nodes. A graph is a \define{tree} if it is connected and has no simple cycles. A tree may contain a specially designated node called the \define{root}. The nodes of degree 1 in a tree, other than the root, are called the \define{leaves} of the tree. \\ 

A \define{directed graph} has arrows instead of lines. The number of arrows pointing from a particular node is the \define{outdegree} of that node, and the number of arrows pointing to a particular node is the \define{indegree}. \\ 

A path in which all the arrows point in the same direction as its steps is called a \define{directed graph}. A directed graph is \define{strongly connected} if a directed path connects every two nodes. 

\subsubsection{Strings and Languages}

Strings of characters are fundamental building blocks in computer science. The alphabet over which the strings are defined may vary with the application. For our purposes, we define an \define{alphabet} to be any nonemtpy finite set. The members of the alphabet are \define{symbols} of the alphabet. We generally use capital Greek letter $\Sigma$ and $\Gamma$ to dersignate alphabets. \\ 

A \textbf{string over an alphabet} is a finite sequence of syumbols from that alphabet, usually written next to one another and not separated by commas. If $w$ is a string over $\Sigma$, the \define{length} of $w$, written $\vert w \vert$ is the number of symbols that it contains. The string of length zero is called the \define{empty string} and is written $\epsilon$. The \define{reverse} of $w$, written $w^{R}$, is the string obtained by writing $w$ in the opposite order. String $z$ is a \define{substring} of $w$ if $z$ appears consecutively within $w$. \\ 

If we have a string $x$ of length $m$ and string $y$ of length $n$, the \define{concatenation} of $x$ and $y$, written $xy$, is the string obtained by appending $y$ to the end of $x$, as in $x_1 \cdots x_{m}y_1 \cdots y_n$. \\ 

The \define{lexicographic order} of strings is the same as the familiar dictionary order. We'll occasionally use a modified lexicographic order, called \define{shortlex order} or simply \define{string order}, that is identical to lexicographic order, except that shorter strings precede longer strings. Thus the string ordering of all strings over the alphabet $\{0,1\}$ is $$(\epsilon,0,1,00,01,10,11,000,\dots)$$ Say that string $x$ is a \define{prefix} of string $y$ if a string $z$ exists where $xz = y$, and that $x$ is a \define{proper prefix} of $y$ if in addition $x \neq y$. A \define{language} is a set of strings. A language is a \define{prefix-free} if no member is a proper prefix of another member. 

\subsubsection{Boolean Logic}

\define{Boolean logic} is a mathematical system built around the two values TRUE and FALSE. The values TRUE and FALSE are called the \define{Boolean values} and are often represented by the values 1 and 0. \\ 

  We can manipulate Boolean values with the \define{boolean operations}. The simplest boolean operation is the \define{negation} or \define{NOT} operation, designated with the symbol $\neg$. The negation of a Boolean value is the opposite value. We designate the \define{conjunction} or \define{AND} operation with the symbol $\land$. The conjunction of two Boolean values is 1 if both of those values are 1. The \define{disjunction} or \define{OR} operation is designated with the symbol $\lor$. The disjunction of two Boolean values is 1 if either of those values is 1. \\ 

  The \define{exclusive or} or \define{XOR} operation is designated by the $\oplus$ symbol and is 1 if either but not both of its two operands is 1. The \define{equality} operation, written $\leftrightarrow$, is 1 if both if its operandws have the same value. Finally, the \define{implication} operation is designated by the symbol $\rightarrow$ and is 0 if its first operand is 1 and its second operand is 0; otherwise, $\rightarrow$ is 1. \\ 

The \define{distributive law} for AND and OR comes in handy when we manipulate Boolean expression; it comes in two forms: 

\begin{itemize}
  \item $P \land (Q \lor R) \textrm{ equals } (P \land Q) \lor (P \land R) \textrm{, and its dual}$
  \item $P \lor (Q \land R) \textrm{ equals } (P \lor Q) \land (P \lor R)$
\end{itemize}

\subsection{Definitions, Theorems, and Proofs}

\define{Definitions} describe the objects and notions that we use. When defining some object, we must make clear what constitutes that object and what does not. \\

After we have defined various objects and notions, we usually make \define{mathematical statements} about them. Typically, a statement expresses that some object has a certain property. \\

A \define{proof} is a convincing logical argument that a statement is true. \\ 

A \define{theorem} is a mathematical statement proved true. Occasionally, we prove statements that are interesting only because they assist in the proof of another, more significant statement. Such statements are called \define{lemmas}. Occasionally a theorem or its proof may allow us to conclude easily that other, related statements are true. These statements are called \define{corollaries} of the theorem. 

\subsubsection{Finding Proofs}

The only way to determine the truth or falsity of a mathematical statement is with a mathematical proof. Experimenting with examples is especially helpful. Thus if the statement says that all objects of a certain type have a particular property, pick a few objects of that type and observe that they actually do have that property. After doing so, try to find an object that fails to have the property, called a \define{counterexample}. If the statement actually is true, you will not be able to find a counterexample. 

\subsection{Types of Proofs}
Several types of arguments arise frequently in mathematical proofs. Here, we describe a few that often occur in the theory of computation. 

\subsubsection{Proof by Construction}

Many theorems state that a particular type of object exists. One way to prove such a theorem is by demonstrating how to construct the object. This technique is a \define{proof by construction}. 

\subsubsection{Proof by Contradiction}

In one common form of argument for proving a theorem, we assume that the theorem is false and then show that this assumption leads to an obviously false consequence, called a contradiction. 

\subsubsection{Proof by Induction}

Proof by induction is an advanced method used to show that all elements of an infinite set have a specified property. For example we may use a proof by induction to show that an arithmetic expression computes a desired quantity for every assignment to its variables, or that a program works correctly at all steps or for all inputs. \\ 

Every proof by induction consists of two parts, the \define{basis} and the \define{induction step}. Each part is an individual proof on its own. In the induction step, the assumption that $P(i)$ is true is called the \define{induction hypothesis}. \\

\bold{Basis:} Prove that $P(i)$ is true. 
\bold{Induction step:} For each $i \geq 1$, assume that $P(i)$ is true and use this assumption to show that $P(i+1)$ is true. \\ 

\section{Regular Languages}

Real computers are quite complicated: too much so to allow us to set up a manageable mathematical theory of them directly. Instead, we use an idealized computer called a \define{computational model}. As with any model in science, a computational model may be accurate in some ways but perhaps not in others. Thus we will use several different computation models, depending on the features we want to focus on. We begin with the simplest model, called the \define{finite state machine} or \define{finite automaton}. 

\subsection{Finite Automatata}

Finite automata are good models for computers with an extremely limited amount of memory. Finite automatat and their probabilistic counterpart \define{Markov chains} are useful tools when we are attempting to recognize patterns in data. \\ 

Finite automata can be represented by a \define{state diagram}. The \define{start state} is indicated by the arrow point at it from nowhere. The \define{accept state} is the one with a double circle. The arrows going from one state to another are called \define{transitions}. When this such automation receives an input, it processes that and produces an output; the output is either \define{accept} or \define{reject}. 

\subsubsection{Formal Definition of Finite Automaton}

A finite automaton has several parts. It has a set of states and rules for going from one state to another, depending on the input symbol. It has an input alphabet that indicates the allowed input symbols. It has a tart state and a set of accept states. The formal definition says that a finite automaton is a list of those five objects: set of states, input alphabet, rules for moving, start state, and accept states. In mathematical language, a list of five elements is often called a 5-tuple. Hence we define a finite automaton to be a 5-tuple consisting of these five parts. \\

We use something called a \define{transition function}, frequently denoted $\delta$, to define the rules for moving. If the finite automaton has an arrow from a state $x$ to a state $y$ labeled with the input symbol 1, that means that if the automaton is in state $x$ when it reads a 1, it then moves to state $y$. We can indicate the same thing with the transition function by saying that $\delta(x,1) = y$. This notation is a kind of mathematical shorthand. \\ 

\begin{definition}[Finite automaton] A 5-tuple $(Q,\Sigma,\delta,q_{0},F)$, where 
\begin{enumerate}
  \item $Q$ is a finite set called the \define{states},
  \item $\Sigma$ is a finite set called the \define{alphabet},
  \item $\delta$: $Q \times \Sigma \rightarrow Q$ is the \define{transition function},
  \item $q_{0} \in Q$ is the \define{start state}, and 
  \item $F \subseteq Q$ is the \define{set of accept states} 
\end{enumerate}
\end{definition}

If $A$ is the set of all strings that machine $M$ accepts, we say that $A$ is the \define{language of machine M} and write $L(M) = A$. We say that \define{M recognizes A} or that \define{M accepts A}. Because the term \emph{accept} has different meanings when we refer to machines accepting strings and machines accepting languages, we prefer the term \emph{recognize} for languages in order to avoid confusion. \\ 

A machine may accept several strings, but it always recognizes only one language. If the machine accepts no strings, it still recognizes one language-namely, the empty language  $\emptyset$. 

\subsubsection{Formal Definition of Computation}

Let $M = (Q, \Sigma, \delta, q_{0}, F)$ be a finite automaton and let $w=w_{1}w_{2} \cdots w_{n}$ be a string where each $w_{i}$ is a member of the alphabet $\Sigma$. Then $M$ \define{accepts} $w$ if a sequence of states $r_{0}, r_{1}, \dots, r_{n}$ in $Q$ exists with three conditions:

\begin{enumerate}
  \item $r_0 = q_0$,
  \item $\delta(r_{i},w_{i+1}) = r_{i+1}$, for $i=0, \dots, n-1$, and 
  \item $r_{n} \in F$
\end{enumerate}

Condition 1 says that the machine starts in the start state. Condition 2 says that the machine goes from state to state according to the transition function. Condition 3 says that the machine accepts its input if it ends up in an accept state. We say that $M$ \define{recognizes language} $A$ if $A = \{w \vert M \textrm{ accepts } w \}$. 

\begin{definition}
  In state $q$, if the next input symbol is $a$, the next state is $\delta(q,a)$. \\ 
  \define{Define:} $\Delta: Q \times \Sigma * \rightarrow Q$ recursively as follows: \\  \\ 
    $\Delta(q,\epsilon) = q$ \\ 
    $\Delta(q,ax) = \Delta(\delta(q,a)), a \in \Sigma, x \in \Sigma *$ \\ \\
  $M = (Q,\Sigma,\delta, q_0, F)$ \define{accepts} a string $w = w_{1}w_{2} \cdots w_{n}$ iff $\Delta(q_{0},w) \in F$
\end{definition}

\begin{definition}[Regular Language] 
  A language that is recognized by some finite automaton
\end{definition}

\subsubsection{Designing Finite Automata}

Try putting yourself in the place of the machine you are trying to design and then see how you would go about performing the machine's task. Suppose that you are given some language and want to design a finite automaton that recognizes it. Pretending to be the automaton, you receive an inpuit string and must determine whether it is a member of the language the automaton is supposed to recognize. First, in order to make these decisions, you have to figure out what you need to remember about the string as you are reading it. For many languages, you don't need to remember the entire input. You need to remember only certain crucial information. Exactly which information is crucial depends on the particular language considered. \\ 

Once you have determined the necessary information to remember about the string as it is being read, you represent this information as a finite lit of possibilities. Then you assign a state to each of the possibilities. Next, you assign the transitions by seeing how to go from one possibility to another upon reading a symbol. Next, you set the start state to be the stae corresponding to the possibility associated with having seen 0 symbols so far. Last, set the accept states to be those corresponding to the possibilities where you want to accept the input string. 

\subsubsection{The Regular Operations}

In the theory of computation, the objects are languages and the tools include operations specifically designed for manipulating them. We define three operatioons on languages, called the \define{regular operations}, and use them to study properties of the regular languages. 

\begin{define}[Regular Operations]
  Let $A$ and $B$ be languages. We define the regular operations \define{union}, \define{concatenation}, and \define{star} as follows:
  \begin{itemize}
    \item \define{Union}: $A \cup B = \{x  \vert x \in A \textrm{ or } x \in B \}$ 
    \item \define{Concatenation}: $A \circ B = \{xy \vert x \in A \textrm{ and } y \in B \}$ 
    \item \define{Star}: $A* = \{x_{1}x_{2} \dots x_{k} \vert k \geq 0 \textrm{ and each } x_{i} \in A \}$
  \end{itemize}
\end{define}

The union operation takes all the strings in both $A$ and $B$ and lumps them together into one language. The concatenation operation attaches a string from $A$ in front of a string from $B$ in all possible ways to get the strings in the new language. The star operation is \define{unary operation} instead of a \define{binary operation}. It works by attaching any number of strings (including 0) in $A$ together to get a string in the new language. Even if $A$ doesn't contain the empty string, $A*$ \emph{does} contain the empty string. 

\begin{example}
  Let $A = \{oreo,ginger\} \textrm{ and } B = \{cookie,icecream\}$... \\ 
  $A \cup B = \{oreo,ginger,cookie,icecream\}$ \\ 
  $A \circ B = \{oreocookie,oreoicecream,gingercookie,gingericecream\}$ \\ 
  $A* = \{\epsilon,oreo,ginger, \dots\}$ \\
\end{example}

\begin{proof}
  \bold{Proof:} Let $A,B$ be regular languages recognized by DFAs $M_1$ and $M_2$. \\ 
  Let $M_1 = (Q_1, \Sigma, \delta_1, q_1, F_1)$ and $M_2 = (Q_2, \Sigma, \delta_2, q_2, F_2)$ \\ 
  Define a new DFA $M = (Q, \Sigma, \delta, q, F)$: \\ 
  $Q = Q_1 \times Q_2$ \hfill each state of $M$ is a pair of states, one from $M_1$, and the other from $M_2$ \\ 
  $\delta((r_1, r_2),a) = (\delta_1(r_1,a), \delta_2(r_2,a))$ \hfill a transition in $M$ tracks transitions in both $M_1 ,M_2$ \\
  $q_0 = (q_1, q_2)$ \hfill start $M$ in the start states of $M_1, M_2$ \\ 
  $F = (F_1 \times Q_2) \cup (Q_1 \times F_2)$ \hfill accept if one of the machines end in an accept state \\ 
  $\cdots$A formal proof of correctness proceeds by induction on the length of the input string$\cdots$
\end{proof}

\subsection{Nondeterminism}

When a machine is in a given state and reads the next input symbol, we know what the next state will be---it is determined. We call this \define{deterministic} computation. In a \define{nondeterministic} machine, several choices may exist for the next state at any point. Nondeterminism is a generalization of determinism, so every determinsitic finite automaton is atuomatically a nondeterministic finite automaton. \\ 

Machine is initially in start state. From the start state, clones appear in all states reachable using only $\epsilon$ transitions. Each clone in its current state. 
\begin{enumerate}
  \item Reads the next input symbol $a$ 
  \item If there is no outgoing transition labeeld $a$: the clone dies 
  \item For each outoging transition labeled $a$: a clone appears at the next state 
  \item ...
\end{enumerate}

Every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabet. NFAs may violate that rule. In an NFA, a state may have zero, one, or many exiting arrows for ecah alphabet symbol. Additionally, in a DFA, labels on the transition arrows are symbols from the alphabet. An NFA may have arrows labeled with members of the alphabet or $\epsilon$. Zero, one, or many arrows may exit from each state with the label $\epsilon$. \\ 

So how does an NFA compute$\dots$ Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceed. After reading said symbol, the machine splits into multiple copies of itself and follows \emph{all} the possibilities in parallel. Each copy of the machine takes one of the possible ways to proceed and continues as before. If there are subsequent choices, the machine splits again. If the next input symbol doesn't appear on any of the arrows exiting the state occupied by a copy of the machine, that copy of the machine dies, along with the branch of the computation associated with it. Finally, if \emph{any one} of these copies of the machine is in an accept state at the end of the input, the NFA accepts the input string. \\ 

If a state with an $\epsilon$ symbol on an exiting arrow is encountered, something similar happens. Without reading any input, the machine splits into multiple copies, one following each of the exiting $\epsilon$-labeled arrows and one staying at the current state. Then the machine proceeds nondeterministically as before. \\ 

\begin{definition}[Nondeterministic Finite State Automata (NFA)] 
 a 5-tuple $(Q,\Sigma,\delta,q_0,F)$, where
  \begin{enumerate}
    \item $Q$ is a finite set of states 
    \item $\Sigma$ is a finite alphabet 
    \item $\delta: Q \times \Sigma_{\epsilon} \rightarrow P(Q)$ is the transition function 
    \item $q_0 \in Q$ is the start state 
    \item $F \subseteq Q$ is the set of accept states
  \end{enumerate}
  For any set $Q$ we write $P(Q)$ to be the collection of all subsets of $Q$. Here $P(Q)$ is called the \define{power set} of $Q$. For any alphabet $\Sigma$, we write $\Sigma_{\epsilon}$ to be $\Sigma \cup \{\epsilon\}$. Thus, we can write the formal description of the type of the transitioon function in an NFA as $\delta: Q \times \Sigma_{\epsilon} \rightarrow P(Q)$. 
\end{definition}

\begin{definition}[Compuitation for an NFA]
  Let $N=(Q,\Sigma,\delta,q_0,F)$ be an NFA and $w$ a string over the alphabet $\Sigma$. Then we say that $N$ \emph{accepts} $w$ if we can write $w$ as $w = y_{1}y_{2}\cdots y_{m}$, where each $y_i$ is a member of $\Sigma_{\epsilon}$ and a sequence of states $r_0 , r_1 , \dots , r_{m}$ exists in $Q$ with three conditions.  \\ 
  \begin{enumerate}
    \item $r_0 = q_0$ 
    \item $r_{i + 1} \in \delta(r_{i}, y_{i+1})$, for $i = 0, \dots , m-1$ 
    \item $r_m \in F$
  \end{enumerate}
  Condition 1 says that the machine starts out in the start state. Condition 2 says that state $r_{i+1}$ is one of the allowable next states when $N$ is in the state $r_i$ and reading $y_{i+1}$. Observe that $\delta(r_{i},y_{i+1})$ is the \emph{set} of allowable next states and so we say that $r_{i+1}$ is a member of that set. Finally, condition 3 says that the machine accepts its input if the last state is an accept state. 
\end{definition}

\subsection{Equivalence of NFAs and DFAs}

Deterministic and nondeterministic finite automato recognize the same class of languages. Say that two machines are \define{equivalent} if they recognize the same language. 

\begin{theorem}
  Every nondeterministic finite automaton has an equivalent deterministic finite automaton
\end{theorem}

\begin{lemma}
  A language is regular if and only if some nondeterminstic finite automaton recognizes it. \\ 
  One part of the conditioon states that a language is regular if some NFA recognizes it. Consequently, if an NFA recognizes some language, so does some DFA, and hence the language is regular. The condition also states that a language is regular only if some NFA recognizes it. That is, if a language is regular, some NFA must be recognizing it. 
\end{lemma}

For a NFA with $n$ states, the equivalent NFA will need to have $2^{n}$ states. 

\subsection{Closure under the Regular Operations}

\begin{theorem}
  The class of regular languages is closed under the union operation. In other words, if $A,B$ are both regular langauges then $A \cup B$ is regular as well.  
\end{theorem}

\begin{theorem}
  The class of regular languages is closed under the concatenation operation. 
\end{theorem}

\begin{theorem}
  The class of regular languages is closed under the star operation. 
\end{theorem}

\section{Regular Expressions} 

We can use the regular operations to build up expressions describing languages, which are called \define{regular expressions}. The value of a regular expression is a language. 

\begin{definition}[Formal Definition of a Regular Expression]
  Say that $R$ is a \define{regular expression} if $R$ is$\dots$ 
  \begin{enumerate}
    \item $a$ for some $a$ in the alphabet $\Sigma$ 
    \item $\epsilon$ 
    \item $\emptyset$ 
    \item $(R_1 \cup R_2)$, where $R_1$ and $R_2$ are regular expressions 
    \item $(R_1 \circ R_2)$, where $R_1$ and $R_2$ are regular expressions 
    \item $(R_{1}^{*})$, where $R_1$ and $R_2$ are regular expressions 
  \end{enumerate}
  In items 1 and 2, the regular expressions $a$ and $\epsilon$ represent the languages $\{a\}$ and $\{\epsilon \}$, respectively. In item 3, the regular expression $\emptyset$ represents the empty language. In items 4, 5, and 6, the expressions represent the languages obtained by taking the union or concatenation of the languages $R_1$ and $R_2$, or the star of the language $R_1$, respectively.  
\end{definition}

\begin{remark}
  The expression $\epsilon$ represents the language containing a single string---namely, the empty string---wheras $\emptyset$ represents the language that doesn't contain any strings. 
\end{remark}

\begin{remark}
  If we let $R$ be any regular expression, we have the following identities. 
  \begin{itemize}
    \item $R \cup \emptyset = R$ \\ Adding the empty language to any other language will not change it 
    \item $R \circ \epsilon = R$ \\ Joining the empty string to any string will not change it
  \end{itemize}
  However, exchanging $\emptyset$ and $\epsilon$ in the preceding identities may cause the equalities to fail. 
  \begin{itemize}
    \item $R \cup \epsilon$ may not equal $R$. \\ For example if $R = 0$, then $L(R) = \{0\} but L(R \cup \epsilon) = \{0,\epsilon \}$. 
    \item $R \circ \emptyset$ may not equal $R$. \\ For example if $R = 0$, then $L(R) = \{0\}$ but $L(R \circ \emptyset) = \emptyset$ (i.e. $R \cup \epsilon = R iff \epsilon \in R$). 
    \item $R \circ \emptyset = \emptyset$ 
    \item $R \circ \epsilon = R$ 
    \item $\emptyset^{*} = \{\epsilon\}$ 
  \end{itemize}
\end{remark}

\begin{example}
  \item Let $\Sigma = \{0,1\}$
  \begin{itemize}
    \item $L_1 = \{\textrm{3rd last bit is 1}\}$ \\ 
      $(0 \cup 1)^{*} 1 (0 \cup 1) (0 \cup 1)$ or $\Sigma^{*}1\Sigma\Sigma$
  \item $L_2 = \{\textrm{strings in which every 0 is followed by at least one 1}\}$ \\
    $(0 1 \cup 1)^{*}$ or $1^{*}(011^{*})^{*}$
  \item $L_3 = \{\textrm{strings starting with 0 and followed by any number of 1s OR strings with no 0}\}$ \\ 
    $01^{*} \cup 1^{*}$ or $(0 \cup \epsilon)1^{*}$
  \item $L_4 = \{\textrm{strings with lengths that are multiples of 3}\}$ \\ 
    $((0 \cup 1) (0 \cup 1) (0 \cup 1))^{*}$ or $(\Sigma \Sigma \Sigma)^{*}$
  \item $L_5 = \{\textrm{strings that end with 01}\}$ \\ 
    $\Sigma^{*} 01$
  \end{itemize}
\end{example}

Elemental objects in a programming language, called \define{tokens}, such as the variable names and constants, may be described with regular expressions. Once the syntax of a programming language has been described with a regular expression in terms of its toekns, automatic systems can generate the \define{lexical analyzer}, the part of a compiler that initially process the input program.  

\subsection{Equivalence with Finite Automata}

Regular expressions and finite automata are equivalent in their descriptive power. However, any regular expression can be converted into a finite automaton that recognizes the language it describes, and vice versa. 

\begin{theorem}
  A language is regular if and only if some regular expression describes it.
\end{theorem}

\begin{lemma}
  If a language is described by a regular expression, then it is regular. 
\end{lemma}

\begin{lemma}
  If a language is regular, then it is described by a regular expression
\end{lemma}

\begin{definition}[Generalized nondeterministic finite automaton]
  are nondeterministic finite automata wherein the transition arrows may have any regular expressions as labels, instead of only memebers of the alphabet or $\epsilon$. The GFNA reads blocks of symbols from the input, not necessarily just one symbol at a time as in an ordinary NFA. The GFNA moves along a transition arrow connecting two states by reading a block of symbols from the input, which themselves constitute a string described by the regular expression on that arrow. \\ 

  \bold{Like an NFA}, but the \emph{start state} has no incoming transition and has outoging transitions to every state. The \emph{accept state} has no outgoing transition, has incoming transitions from every state, and is distinct from the start state. All the \emph{other states} have outgoing transitions to every state. Transitions are labeled with regular expressions. 
\end{definition}

\begin{definition}[DFA to GFNA Conversion]
  \begin{enumerate}
    \item Convert the DFA into a generalized NFA (DFA $M$ $\rightarrow$ GNFA $G$)
      \begin{itemize}
        \item Create a new start state with outgoing $\epsilon$-transition to the start state of $M$ 
        \item Create a new accept state with incoming $\epsilon$-transitions from every accept state of $M$ 
        \item If there are multiple labels on any transition, replace it with the union of the labels
      \end{itemize}
    \item Derive the regular expression from the GNFA. \\ 
      The idea is to manipulate labels so that the label on $(s,a)$ describes all strings accepted by the GNFA. Elimintae states one-at-a-time updating labels at each step. /
  \end{enumerate}
\end{definition}

\begin{definition}[Formal Definition of GFNA]
  A \define{generalized nondeterministic finite automaton} is a 5-tuple, $(Q,\Sigma,\delta,q_{\textrm{start}},q_{\textrm{accept}})$, where 
  \begin{enumerate}
    \item $Q$ is the fintie set of states 
    \item $\Sigma$ is the input alphabet 
    \item $\delta : (Q - \{q_{\textrm{accept}}\}) \times (Q - \{q_{\textrm{start}}\}) \rightarrow R$ is transition function
    \item $q_{\textrm{start}}$ is the start state 
    \item $q_{\textrm{accept}}$ is the accept state
  \end{enumerate}
\end{definition}

A GFNA accepts a string $w$ in $\Sigma^{*}$ if $w=w_1 w_2 \dots w_k$, where each $w_i$ is in $\Sigma^{*}$ and a sequence of states $q_0 , q_1 , \dots , q_k$ exists such that 
\begin{enumerate}
  \item $q_0 = q_{\textrm{start}}$ is the start state, 
  \item $q_k = q_{\textrm{accept}}$ is the accept state 
  \item for each $i$, we have $w_i \in L(R_i)$, where $R_i = \delta(q_i - 1, q_i)$; in other words, $R_i$ is the expression on the arrow from $q_{i-1}$ to $q_i$. 
\end{enumerate}

\begin{theorem}
  For every regular language $L$, there exists a \emph{unique} minimal DFA $M$ such that $L=L(M)$. However, this is \emph{not true} for NFAs; there is not necessarily a unique minimal DFA.  
\end{theorem}

\begin{definition}[Indistinguishable States]
  States $p$ and $q$ are indistinguishable: $p \sim q$ if for every string $w$, the computation starting in state $p$ reaches an accept state if and only if the computation from $q$ reaches an accept state. 
\end{definition}

\begin{lemma}
  The indistinguishability relation, $\sim$, is an equivalence relation. \bold{Proof}$\dots$
  \begin{itemize}
    \item \bold{Reflexive}: $p \sim p$ 
    \item \bold{Symmetric}: $p \sim q \leftrightarrow q \sim p$
    \item \bold{Transitive}: $(p \sim q \cap q \sim r) \rightarrow p \sim r$
  \end{itemize}
\end{lemma}

\begin{lemma}[The Distinguishability Lemma]
  If for some symbol $\delta(p,a) \not\sim \delta(q,a)$ then $p \not\sim q$
\end{lemma}

\begin{definition}[Finding Distinguishable Pairs of States]. \\
  \bold{Initialize}: Create an empty set $D$ which will store pairs of distnguishable states 
  \bold{Step 0}: \\ 
  Add all pairs $(p,a)$ where exactly one is an accept state to $D$. While True do: Scan over all pairs $(p,q)$ of states not yet distinguished. For each alphabet symbol $a$. If the pair $(\delta(p,a),\delta(q,a))$ is a distinguished, add $(p,q)$ to $D$. If no new pair of states is added to $D\dots$ break. Return D
\end{definition}

\section{Nonregular Languages}

% page 101

\end{document}
